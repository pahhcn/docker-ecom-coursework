# 部署和运行指南

## 目录
- [环境要求](#环境要求)
- [快速开始](#快速开始)
- [Docker Compose 部署](#docker-compose-部署)
- [Kubernetes 部署](#kubernetes-部署)
- [Jenkins CI/CD 部署](#jenkins-cicd-部署)
- [监控系统部署](#监控系统部署)
- [蓝绿部署](#蓝绿部署)
- [验证和测试](#验证和测试)
- [常见问题](#常见问题)

---

## 环境要求

### 基础环境
- **操作系统**: Linux (推荐 Ubuntu 20.04+) / macOS / Windows (WSL2)
- **Docker**: 20.10+ 
- **Docker Compose**: 2.0+
- **Git**: 2.30+

### Kubernetes 部署所需
- **Minikube**: 1.30+ 或其他 Kubernetes 集群
- **kubectl**: 1.28+
- **内存**: 至少 4GB 可用内存
- **CPU**: 至少 2 核

### CI/CD 所需
- **Java**: JDK 17+
- **Maven**: 3.8+
- **Jenkins**: 2.400+ (可选，可使用 Docker 运行)

---

## 快速开始

### 1. 克隆项目
```bash
git clone https://github.com/pahhcn/docker-ecom-coursework.git
cd docker-ecom-coursework
```

### 2. 使用 Docker Compose 一键部署
```bash
# 构建并启动所有服务
docker-compose up -d

# 查看服务状态
docker-compose ps

# 查看日志
docker-compose logs -f
```

### 3. 访问服务
- **前端页面**: http://localhost:8080
- **后端API**: http://localhost:8081/api/products
- **API文档**: http://localhost:8081/swagger-ui.html
- **数据库**: localhost:3306 (用户名: root, 密码: rootpassword)

### 4. 停止服务
```bash
docker-compose down

# 同时删除数据卷
docker-compose down -v
```

---

## Docker Compose 部署

### 标准部署

#### 1. 环境变量配置（可选）
创建 `.env` 文件自定义配置：
```bash
# 数据库配置
MYSQL_ROOT_PASSWORD=rootpassword
MYSQL_DATABASE=ecommerce
MYSQL_USER=ecomuser
MYSQL_PASSWORD=ecompass

# 后端配置
SPRING_DATASOURCE_URL=jdbc:mysql://database:3306/ecommerce
SPRING_DATASOURCE_USERNAME=root
SPRING_DATASOURCE_PASSWORD=rootpassword

# 端口配置
FRONTEND_PORT=8080
BACKEND_PORT=8081
DATABASE_PORT=3306
```

#### 2. 启动服务
```bash
# 后台运行
docker-compose up -d

# 前台运行（查看实时日志）
docker-compose up

# 指定服务启动
docker-compose up -d frontend backend
```

#### 3. 服务管理
```bash
# 重启服务
docker-compose restart

# 重启特定服务
docker-compose restart backend

# 停止服务
docker-compose stop

# 删除服务（保留数据卷）
docker-compose down

# 删除服务和数据卷
docker-compose down -v
```

#### 4. 查看状态和日志
```bash
# 查看服务状态
docker-compose ps

# 查看所有日志
docker-compose logs

# 查看特定服务日志
docker-compose logs backend

# 实时跟踪日志
docker-compose logs -f backend

# 查看最近 100 行日志
docker-compose logs --tail=100 backend
```

### 监控部署

启动包含 Prometheus、Grafana 和 Alertmanager 的监控栈：

```bash
# 启动监控服务
docker-compose -f docker-compose.monitoring.yml up -d

# 查看监控服务状态
docker-compose -f docker-compose.monitoring.yml ps
```

访问监控服务：
- **Prometheus**: http://localhost:9090
- **Grafana**: http://localhost:3000 (admin/admin)
- **Alertmanager**: http://localhost:9093

---

## Kubernetes 部署

### 使用 Minikube 本地部署

#### 1. 启动 Minikube 集群
```bash
# 启动集群（使用 Docker 驱动）
minikube start --driver=docker

# 配置 kubectl 别名（可选）
alias kubectl="minikube kubectl --"

# 验证集群状态
kubectl cluster-info
kubectl get nodes
```

#### 2. 创建命名空间
```bash
# 创建 ecommerce 命名空间
kubectl apply -f k8s/namespace.yaml

# 验证命名空间
kubectl get namespaces
```

#### 3. 部署应用

##### 方式一：使用部署脚本（推荐）
```bash
cd k8s
./deploy.sh
```

##### 方式二：手动部署
```bash
# 部署数据库
kubectl apply -f k8s/database/

# 等待数据库就绪
kubectl wait --for=condition=ready pod -l app=database -n ecommerce --timeout=300s

# 部署后端
kubectl apply -f k8s/backend/

# 等待后端就绪
kubectl wait --for=condition=ready pod -l app=backend -n ecommerce --timeout=300s

# 部署前端
kubectl apply -f k8s/frontend/

# 等待前端就绪
kubectl wait --for=condition=ready pod -l app=frontend -n ecommerce --timeout=300s
```

#### 4. 访问应用

使用 Minikube 服务访问：
```bash
# 获取前端服务 URL
minikube service frontend -n ecommerce --url

# 在浏览器中打开前端
minikube service frontend -n ecommerce

# 获取后端服务 URL
minikube service backend -n ecommerce --url
```

使用 Port Forward：
```bash
# 前端
kubectl port-forward -n ecommerce svc/frontend 8080:80

# 后端
kubectl port-forward -n ecommerce svc/backend 8081:8080

# 数据库
kubectl port-forward -n ecommerce svc/database 3306:3306
```

#### 5. 查看部署状态
```bash
# 查看所有资源
kubectl get all -n ecommerce

# 查看 Pod 状态
kubectl get pods -n ecommerce

# 查看服务
kubectl get services -n ecommerce

# 查看持久卷
kubectl get pv,pvc -n ecommerce

# 查看 Pod 日志
kubectl logs -f -n ecommerce -l app=backend

# 查看 Pod 详情
kubectl describe pod -n ecommerce <pod-name>
```

#### 6. 测试部署
```bash
cd k8s
./test-deployment.sh
```

#### 7. 清理资源
```bash
# 使用清理脚本
cd k8s
./cleanup.sh

# 手动清理
kubectl delete namespace ecommerce

# 停止 Minikube
minikube stop

# 删除 Minikube 集群
minikube delete
```

### 蓝绿部署

蓝绿部署允许零停机时间更新应用：

#### 1. 部署蓝色环境（当前生产环境）
```bash
kubectl apply -f k8s/blue-green/blue-deployment.yaml
kubectl apply -f k8s/blue-green/service.yaml
```

#### 2. 部署绿色环境（新版本）
```bash
kubectl apply -f k8s/blue-green/green-deployment.yaml
```

#### 3. 验证绿色环境
```bash
# 端口转发到绿色环境进行测试
kubectl port-forward deployment/backend-green -n ecommerce 8082:8080

# 访问 http://localhost:8082 测试新版本
```

#### 4. 切换到绿色环境
```bash
# 更新服务选择器指向绿色部署
kubectl patch service backend -n ecommerce -p '{"spec":{"selector":{"app":"backend","version":"green"}}}'
```

#### 5. 回滚到蓝色环境（如果需要）
```bash
kubectl patch service backend -n ecommerce -p '{"spec":{"selector":{"app":"backend","version":"blue"}}}'
```

#### 6. 删除旧环境
```bash
# 确认绿色环境稳定后，删除蓝色部署
kubectl delete deployment backend-blue -n ecommerce
```

---

## Jenkins CI/CD 部署

### 本地 Jenkins 部署

#### 1. 启动 Jenkins
```bash
# 使用脚本启动 Jenkins
./run-jenkins-local.sh

# 或手动启动
docker run -d \
  --name jenkins \
  -p 8082:8080 -p 50000:50000 \
  -v jenkins_home:/var/jenkins_home \
  -v /var/run/docker.sock:/var/run/docker.sock \
  jenkins/jenkins:lts
```

#### 2. 初始化 Jenkins
```bash
# 获取初始管理员密码
docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword

# 访问 http://localhost:8082 完成设置向导
```

#### 3. 配置 Jenkins 项目

1. 创建新的 Pipeline 项目
2. 配置 Git 仓库: `https://github.com/pahhcn/docker-ecom-coursework.git`
3. 指定 Pipeline 脚本路径: `Jenkinsfile`
4. 配置参数:
   - `DEPLOY_TARGET`: kubernetes / docker-compose
   - `ENABLE_MONITORING`: true / false
   - `ENABLE_BLUE_GREEN`: true / false

#### 4. 运行流水线
```bash
# 在 Jenkins UI 中点击 "Build with Parameters"
# 或使用 Jenkins CLI
java -jar jenkins-cli.jar -s http://localhost:8082/ build docker-ecom-coursework
```

### 流水线阶段说明

1. **Checkout**: 从 Git 仓库拉取代码
2. **Build Backend**: 编译 Spring Boot 应用
3. **Test**: 运行单元测试和集成测试
4. **Build Images**: 构建 Docker 镜像
5. **Push Images**: 推送镜像到仓库（如果配置）
6. **Deploy**: 部署到目标环境
7. **Deploy Monitoring**: 部署监控栈（可选）
8. **Health Check**: 验证服务健康状态

---

## 监控系统部署

### Kubernetes 监控部署

#### 1. 部署 Prometheus
```bash
kubectl apply -f monitoring/prometheus/prometheus-configmap.yaml
kubectl apply -f monitoring/prometheus/prometheus-deployment.yaml
kubectl apply -f monitoring/prometheus/prometheus-service.yaml
```

#### 2. 部署 Grafana
```bash
kubectl apply -f monitoring/grafana/grafana-deployment.yaml
kubectl apply -f monitoring/grafana/grafana-service.yaml
```

#### 3. 部署 Alertmanager
```bash
kubectl apply -f monitoring/alertmanager/alertmanager-deployment.yaml
kubectl apply -f monitoring/alertmanager/alertmanager-service.yaml
```

#### 4. 访问监控服务
```bash
# Prometheus
kubectl port-forward -n ecommerce svc/prometheus 9090:9090

# Grafana
kubectl port-forward -n ecommerce svc/grafana 3000:3000

# Alertmanager
kubectl port-forward -n ecommerce svc/alertmanager 9093:9093
```

#### 5. 配置 Grafana

1. 访问 http://localhost:3000 (admin/admin)
2. 添加 Prometheus 数据源: http://prometheus:9090
3. 导入仪表板:
   - JVM Micrometer Dashboard (ID: 4701)
   - Spring Boot Statistics (ID: 6756)
   - MySQL Overview (ID: 7362)

### 监控指标说明

- **应用指标**: JVM 内存、GC、线程、HTTP 请求
- **数据库指标**: 连接数、查询性能、慢查询
- **容器指标**: CPU、内存、网络、磁盘
- **自定义业务指标**: 商品查询次数、API 响应时间

---

## 验证和测试

### 健康检查
```bash
# 前端健康检查
curl http://localhost:8080

# 后端健康检查
curl http://localhost:8081/actuator/health

# 数据库连接测试
mysql -h localhost -P 3306 -u root -prootpassword -e "SELECT 1"
```

### API 测试
```bash
# 获取所有商品
curl http://localhost:8081/api/products

# 获取单个商品
curl http://localhost:8081/api/products/1

# 创建商品
curl -X POST http://localhost:8081/api/products \
  -H "Content-Type: application/json" \
  -d '{"name":"测试商品","price":99.99,"stock":100}'

# 更新商品
curl -X PUT http://localhost:8081/api/products/1 \
  -H "Content-Type: application/json" \
  -d '{"name":"更新商品","price":199.99,"stock":50}'

# 删除商品
curl -X DELETE http://localhost:8081/api/products/1
```

### 数据库验证
```bash
# 连接数据库
docker exec -it <database-container-id> mysql -uroot -prootpassword ecommerce

# 或使用 Kubernetes
kubectl exec -it -n ecommerce <database-pod> -- mysql -uroot -prootpassword ecommerce

# 查询数据
SELECT * FROM products;
```

### 运行自动化测试
```bash
# 进入后端目录
cd backend

# 运行单元测试
mvn test

# 运行集成测试
mvn verify

# 运行所有测试并生成报告
mvn clean verify

# 查看测试报告
# target/site/jacoco/index.html
# target/surefire-reports/
```

---

## 常见问题

### 1. 数据库连接失败

**问题**: 后端无法连接到数据库

**解决方案**:
```bash
# 检查数据库容器状态
docker-compose ps database

# 查看数据库日志
docker-compose logs database

# 确认数据库已完全启动
docker-compose exec database mysqladmin ping -h localhost -uroot -prootpassword

# 重启数据库服务
docker-compose restart database
```

### 2. 端口冲突

**问题**: 端口已被占用

**解决方案**:
```bash
# 查看端口占用
sudo lsof -i :8080
sudo netstat -tlnp | grep 8080

# 修改 docker-compose.yml 中的端口映射
# 或停止占用端口的进程
```

### 3. Minikube 启动失败

**问题**: Minikube 无法启动

**解决方案**:
```bash
# 删除并重新创建集群
minikube delete
minikube start --driver=docker

# 如果内存不足，增加分配的资源
minikube start --driver=docker --memory=4096 --cpus=2

# 检查 Docker 服务状态
systemctl status docker
```

### 4. 镜像构建失败

**问题**: Docker 镜像构建出错

**解决方案**:
```bash
# 清理 Docker 缓存
docker builder prune -a

# 重新构建（不使用缓存）
docker-compose build --no-cache

# 检查 Dockerfile 语法
docker build -t test -f backend/Dockerfile backend/
```

### 5. Pod 处于 Pending 状态

**问题**: Kubernetes Pod 一直处于 Pending

**解决方案**:
```bash
# 查看 Pod 详情
kubectl describe pod -n ecommerce <pod-name>

# 检查存储类
kubectl get storageclass

# 检查节点资源
kubectl top nodes

# 如果是 PVC 问题，检查 PV 状态
kubectl get pv,pvc -n ecommerce
```

### 6. 监控数据不显示

**问题**: Grafana 无法显示监控数据

**解决方案**:
```bash
# 检查 Prometheus 目标状态
curl http://localhost:9090/api/v1/targets

# 验证后端暴露了 metrics 端点
curl http://localhost:8081/actuator/prometheus

# 检查 Prometheus 配置
kubectl get configmap prometheus-config -n ecommerce -o yaml

# 重启 Prometheus
kubectl rollout restart deployment prometheus -n ecommerce
```

### 7. Jenkins 流水线失败

**问题**: Jenkins 构建失败

**解决方案**:
```bash
# 检查 Jenkins 日志
docker logs jenkins

# 验证 Docker socket 权限
ls -la /var/run/docker.sock

# 在 Jenkins 容器中测试 Docker
docker exec jenkins docker ps

# 检查 Jenkinsfile 语法
# 使用 Jenkins Pipeline Linter 验证
```

---
